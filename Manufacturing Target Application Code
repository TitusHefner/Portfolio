# Import Necessary Libraries

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
from scipy.stats import norm
import seaborn as sns



                                                                                #Create First Manufacturing Target Class

class value1aManufacturingTarget:
    


    def __init__(self, file_path):
        self.file_path = file_path
        self.df = self.extract_consecutive_values()                             #Initializer for class, setting the file path and extracting consecutive values from a DataFrame.
    
    def extract_consecutive_values(self):
        ogdf = pd.read_csv(self.file_path, delimiter=';')            
        
        start_index = 0
        min_std = float('inf')
        
        for i in range(len(ogdf) - 100):
            std = ogdf.loc[i:i+99, 'value1'].std()
            if std < min_std:
                min_std = std
                start_index = i
                
        selected_values = ogdf.loc[start_index:start_index+99, 'value1']
        df = pd.DataFrame({'value1a': selected_values})
        df['Sample'] = range(1, len(df) + 1)
        
        return df                                                                #Extracts a subset of consecutive values with minimized standard deviation from a DataFrame. Returns a DataFrame with selected values and a 'Sample' column.
    
    def plot_probability(self):
        sns.set(style="ticks")
        fig, ax = plt.subplots(figsize=(6, 4))
        prob = stats.probplot(self.df['value1a'], dist=stats.norm, plot=ax)
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.set_xlabel('Theoretical Quantiles')
        ax.set_ylabel('Ordered Values')
        ax.set_title('Probability Plot Against Normal Distribution')
        plt.show()                                                               #Plots a probability plot against a normal distribution for the selected values in the DataFrame.
        
    def run_anderson_test(self):
        result = stats.anderson(self.df['value1a'], dist='norm')
        print("Statistic: %.3f" % result.statistic)
        print("Critical Values: ", result.critical_values)
        print("Significance Levels: ", result.significance_levels)               #Runs the Anderson-Darling test on the selected values from the DataFrame and prints the test statistic, critical values, and significance levels.
        
    def calculate_cp(self, usl, lsl):
        x = self.df['value1a']
        sigma = x.std()
        cp = (usl - lsl) / (6*sigma)
        self.cp = cp
        print("Process Potential Index (Cp) is: ", cp)                           #Calculates and prints Process Potential Index (Cp) using given limits and data.
        
    def calculate_cpk(self, usl, lsl):
        x = self.df['value1a']
        sigma = x.std()
        m = x.mean()
        cpu = (usl - m) / (3*sigma)
        cpl = (m - lsl) / (3*sigma)
        cpk = np.min([cpu, cpl])
        print("Process Capability (Cpk) is: ", cpk)                              #Calculates and prints Process Capability Index (Cpk) using given limits and data.
      
            
    def process_capability_graph(self):
        sns.set(style="whitegrid")
        fig, ax = plt.subplots(figsize=(8, 5))

        ax.hist(self.df['value1a'], bins='auto', alpha=0.7, density=True, edgecolor='black')

        x_vals = np.linspace(self.df['value1a'].min(), self.df['value1a'].max(), 100)
        pdf = norm.pdf(x_vals, loc=self.df['value1a'].mean(), scale=self.df['value1a'].std())

        ax.plot(x_vals, pdf, 'r', linewidth=2, label='Normal Distribution')
        ax.axvline(self.df['value1a'].mean(), color='r', linestyle='dashed', linewidth=1, label='Process Mean')

        ax.set_xlabel('value1a')
        ax.set_ylabel('Density')
        ax.set_title('Process Capability')

        ax.legend()
        sns.despine()

        plt.show()                                                              #Plots process capability graph with value histogram, normal distribution, and process mean.


    
    def plot_control_chart(self, usl, lsl):
        sns.set(style="whitegrid")
        fig, ax = plt.subplots(figsize=(10, 5))
        x = self.df['value1a']
        sigma = x.std()

        self.df.plot(x='Sample', y='value1a', kind='line', marker='o', ax=ax)

        ax.set_xlabel('Sample')
        ax.set_ylabel('value1a')
        ax.set_title('Control Chart')

        ax.axhline(((usl + lsl)/2), color='g', linestyle='solid', linewidth=1, label='Nominal')
        ax.axhline(((usl + lsl)/2) + sigma * 2, color='b', linestyle='dashed', linewidth=1, label='Proposed Upper Target')
        ax.axhline(((usl + lsl)/2) - sigma * 2, color='b', linestyle='dashed', linewidth=1, label='Proposed Lower Target')
        ax.axhline(usl, color='r', linestyle='solid', linewidth=1, label='Upper Specification Limit')
        ax.axhline(lsl, color='r', linestyle='solid', linewidth=1, label='Lower Specification Limit')

        ax.text(len(self.df) + 1, (((usl + lsl)/2) - (sigma*2)), f"Proposed Lower Target: {(((usl + lsl)/2) - (sigma*2))}", color='black', ha='right')
        ax.text(len(self.df) + 1, (((usl + lsl)/2) + (sigma*2)), f"Proposed Upper Target: {(((usl + lsl)/2) + (sigma*2))}", color='black', ha='right')

        ax.legend()
        sns.despine()

        plt.show()                                                             #Plots a control chart with value1a data, specified targets and limits, and annotations for proposed targets.
        
    def calculate_target_parameters(self, usl, lsl):
        x = self.df['value1a']
        sigma = x.std()
        n = (usl + lsl)/2
        
        UpperTarget = n + (sigma*2)
        LowerTarget = n - (sigma*2)
        delta = UpperTarget - LowerTarget
        tolerance = delta / 2
        
        print("value1a Proposed Upper Target [in mm] is: ", UpperTarget)
        print("value1a Proposed Lower Target [in mm] is: ", LowerTarget)
        print("value1a Delta [in mm] is: ", delta)
        print("value1a Proposed Tolerance Range [in mm]: +/-", tolerance)      #Calculates and prints proposed target parameters for value1a data, including Upper Target, Lower Target, Delta, and Tolerance Range.
        
    def cp_gauge_graph(self, cp):
        sigma_levels = [0, 1, 1.33, 1.67, 2]
        labels = ['Bad', 'Marginal', 'Capable', 'Good', 'Very Good']
        colors = ['red', 'orange', 'yellow', 'lightgreen', 'green']
        num_levels = len(sigma_levels)
        
        closest_index = min(range(len(sigma_levels)), key=lambda i: abs(sigma_levels[i] - cp))
        
        fig, ax = plt.subplots(figsize=(6, 3))
        ax.set_xlim(0, num_levels)
        ax.set_ylim(0, 1)
        ax.set_xticks(range(1, num_levels + 1))
        ax.set_xticklabels(labels)
        ax.spines['left'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['top'].set_visible(False)
        ax.yaxis.set_ticks_position('none')
        ax.xaxis.set_ticks_position('bottom')
        ax.tick_params(axis='x', which='both', bottom=False)
        ax.set_title('Process Capability [Cp] Gauge')
        
        for i in range(num_levels):
            ax.add_patch(plt.Rectangle((i + -.2, 0), 0.6, 0.8, fill=True, color=colors[i], alpha=0.5))
            ax.text(i + 0.5, 0.9, labels[i], ha='center', va='center')
        
        ax.plot(closest_index + 0.5, 0.5, marker='o', markersize=10, color='black')
        
        plt.show()                                                            #Calculates and prints proposed target parameters for value1a data, including Upper Target, Lower Target, Delta, and Tolerance Range.
        

    def run_all(self, usl, lsl):
        cp = self.calculate_cp(usl, lsl)
        cpk = self.calculate_cpk(usl, lsl)
        self.plot_probability()
        self.check_standard_deviation()
        self.cp_gauge_graph(self.cp)
        self.process_capability_graph()
        self.plot_control_chart(usl, lsl)
        self.calculate_target_parameters(usl, lsl)                            #Runs all analysis methods for value



                                                                   

class Value2ManufacturingTarget:                                              #Create Second Manufacturing Target Class
   
    def __init__(self, file_path):
        self.file_path = file_path
        self.df = self.extract_consecutive_values()                           #Initializer for class, setting the file path and extracting consecutive values from a DataFrame.
        

    def extract_consecutive_values(self):
        ogdf = pd.read_csv(self.file_path, delimiter=';')
        
        start_index = 0
        min_std = float('inf')
        
        for i in range(len(ogdf) - 100):
            std = ogdf.loc[i:i+99, 'value2'].std()
            if std < min_std:
                min_std = std
                start_index = i
                
        selected_values = ogdf.loc[start_index:start_index+99, 'value2']
        df = pd.DataFrame({'value2': selected_values})
        
        df['Sample'] = range(1, len(df) + 1)
        
        return df                                                             #Extracts a subset of consecutive values with minimized standard deviation from a DataFrame. Returns a DataFrame with selected values and a 'Sample' column
        
    def plot_probability(self):
        sns.set(style="ticks")
        fig, ax = plt.subplots(figsize=(6, 4))
        prob = stats.probplot(self.df['value2'], dist=stats.norm, plot=ax)
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.set_xlabel('Theoretical Quantiles')
        ax.set_ylabel('Ordered Values')
        ax.set_title('Probability Plot Against Normal Distribution')
        plt.show()                                                            #Plots a probability plot against a normal distribution for the selected values in the DataFrame.
        
    def run_anderson_test(self):
        result = stats.anderson(self.df['value2'], dist='norm')
        print("Statistic: %.3f" % result.statistic)
        print("Critical Values: ", result.critical_values)
        print("Significance Levels: ", result.significance_level)             #Runs the Anderson-Darling test on the selected values from the DataFrame and prints the test statistic, critical values, and significance levels.
        
    def calculate_cp(self, usl, lsl):
        x = self.df['value2']
        sigma = x.std()
        cp = (usl - lsl) / (6*sigma)
        self.cp = cp
        print("Process Potential Index (Cp) is: ", cp)                        #Calculates and prints Process Potential Index (Cp) using given limits and data.
        
    def calculate_cpk(self, usl, lsl):
        x = self.df['value2']
        sigma = x.std()
        m = x.mean()
        cpu = (usl - m) / (3*sigma)
        cpl = (m - lsl) / (3*sigma)
        cpk = np.min([cpu, cpl])
        print("Process Capability (Cpk) is: ", cpk)                           #Calculates and prints Process Capability Index (Cpk) using given limits and data.
 
            
    def process_capability_graph(self, usl, lsl):
        sns.set(style="whitegrid")
        fig, ax = plt.subplots(figsize=(8, 5))
        
        x = self.df['value2']
        sigma = x.std()
        m = x.mean()
        
        ax.hist(x, bins='auto', alpha=0.7, density=True, edgecolor='black')
        
        x_vals = np.linspace(lsl, usl, 100)
        pdf = norm.pdf(x_vals, loc=m, scale=sigma)
        
        ax.plot(x_vals, pdf, 'r', linewidth=2, label='Normal Distribution')
        ax.axvline(m, color='r', linestyle='dashed', linewidth=1, label='Process Mean')
        ax.axvline(lsl, color='g', linestyle='dashed', linewidth=1, label='Lower Specification Limit')
        ax.axvline(usl, color='g', linestyle='dashed', linewidth=1, label='Upper Specification Limit')
        
        ax.set_xlabel('Value2')
        ax.set_ylabel('Density')
        ax.set_title('Process Capability')
        
        ax.legend()
        sns.despine()
        
        plt.show()                                                             #Plots process capability graph with value histogram, normal distribution, and process mean.
        
    def plot_control_chart(self, usl, lsl):
        sns.set(style="whitegrid")
        fig, ax = plt.subplots(figsize=(10, 5))
        
        x = self.df['value2']
        sigma = x.std()
        n = (usl + lsl) / 2
        
        self.df.plot(x='Sample', y='value2', kind='line', marker='o', ax=ax)
        
        ax.set_xlabel('Sample')
        ax.set_ylabel('Value2')
        ax.set_title('Control Chart')
        
        ax.axhline(n, color='g', linestyle='solid', linewidth=1, label='Nominal')
        ax.axhline(n - (sigma * 2), color='b', linestyle='dashed', linewidth=1, label='Proposed Lower Target')
        ax.axhline(n + (sigma * 2), color='b', linestyle='dashed', linewidth=1, label='Proposed Upper Target')
        ax.axhline(usl, color='r', linestyle='solid', linewidth=1, label='Upper Specification Limit')
        ax.axhline(lsl, color='r', linestyle='solid', linewidth=1, label='Lower Specification Limit')

        ax.text(len(self.df) + 1, (n - (sigma*2)), f"Proposed Lower Target: {(n-(sigma*2))}", color='black', ha='right')
        ax.text(len(self.df) + 1, (n + (sigma*2)), f"Proposed Upper Target: {(n + (sigma*2))}", color='black', ha='right')
        
        ax.legend()
        sns.despine()
        
        plt.show()                                                            #Plots a control chart with value1a data, specified targets and limits, and annotations for proposed targets.
        
    def calculate_target_parameters(self, usl, lsl):
        x = self.df['value2']
        sigma = x.std()
        n = (usl + lsl)/2
        
        UpperTarget = n + (sigma * 2)
        LowerTarget = n - (sigma * 2)
        delta = UpperTarget - LowerTarget
        tolerance = delta / 2
        
        print("Value2 Proposed Upper Target [in mm] is: ", UpperTarget)
        print("Value2 Proposed Lower Target [in mm] is: ", LowerTarget)
        print("Value2 Delta [in mm] is: ", delta)
        print("Value2 Proposed Tolerance Range [in mm]: +/-", tolerance)      #Calculates and prints proposed target parameters for value1a data, including Upper Target, Lower Target, Delta, and Tolerance Range.
        
    def cp_gauge_graph(self, cp):
        sigma_levels = [0, 1, 1.33, 1.67, 2]
        labels = ['Bad', 'Marginal', 'Capable', 'Good', 'Very Good']
        colors = ['red', 'orange', 'yellow', 'lightgreen', 'green']
        num_levels = len(sigma_levels)
        
        closest_index = min(range(len(sigma_levels)), key=lambda i: abs(sigma_levels[i] - cp))
        
        sns.set(style="white")
        fig, ax = plt.subplots(figsize=(6, 3))
        ax.set_xlim(0, num_levels)
        ax.set_ylim(0, 1)
        ax.set_xticks(range(1, num_levels + 1))
        ax.set_xticklabels(labels)
        ax.spines['left'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['top'].set_visible(False)
        ax.yaxis.set_ticks_position('none')
        ax.xaxis.set_ticks_position('bottom')
        ax.tick_params(axis='x', which='both', bottom=False)
        ax.set_title('Process Capability [Cp] Gauge')
        
        for i in range(num_levels):
            ax.add_patch(plt.Rectangle((i + 0.2, 0), 0.6, 0.8, fill=True, color=colors[i], alpha=0.5))
            ax.text(i + 0.5, 0.9, labels[i], ha='center', va='center')
            
        ax.plot(closest_index + 0.5, 0.5, marker='o', markersize=10, color='black')
        
        plt.show()                                                           #Plots a Cp gauge graph showing process capability levels and highlighting the closest level to the provided Cp value.
        
    def run_all(self, usl, lsl):
        cp = self.calculate_cp(usl, lsl)
        cpk = self.calculate_cpk(usl, lsl)
        self.plot_probability()
        self.check_standard_deviation()
        self.cp_gauge_graph(self.cp)
        self.process_capability_graph(usl, lsl)
        self.plot_control_chart(usl, lsl)
        self.calculate_target_parameters(usl, lsl)                           #Runs all methods




#Import necessary libraries

import sys
from PyQt6.QtWidgets import QApplication, QMainWindow, QLabel, QVBoxLayout, QWidget, QPushButton, QFileDialog, QLineEdit, QTabWidget, QScrollArea
from PyQt6.QtCore import Qt                                                  

                                                                            #Create application class

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Manufacturing Target Analysis")
        self.resize(800, 600)

        self.tab_widget = QTabWidget(self)  
        self.setCentralWidget(self.tab_widget)

        self.tab_value1a = QWidget()                                         
        self.tab_widget.addTab(self.tab_value1a, "value1a")

        self.tab_Value2 = QWidget()                                          
        self.tab_widget.addTab(self.tab_Value2, "Value2")

        self.layout_value1a = QVBoxLayout(self.tab_value1a)  
        self.layout_Value2 = QVBoxLayout(self.tab_Value2)  

        # Scrollable area
        self.scroll_area_value1a = QScrollArea()
        self.scroll_area_value1a.setWidgetResizable(True)
        self.layout_value1a.addWidget(self.scroll_area_value1a)

        self.scroll_content_value1a = QWidget()
        self.scroll_area_value1a.setWidget(self.scroll_content_value1a)

        self.layout_scroll_value1a = QVBoxLayout(self.scroll_content_value1a)
        self.layout_value1a.addStretch()

        
        self.scroll_area_Value2 = QScrollArea()
        self.scroll_area_Value2.setWidgetResizable(True)
        self.layout_Value2.addWidget(self.scroll_area_Value2)

        self.scroll_content_Value2 = QWidget()
        self.scroll_area_Value2.setWidget(self.scroll_content_Value2)

        self.layout_scroll_Value2 = QVBoxLayout(self.scroll_content_Value2)
        self.layout_Value2.addStretch()

                                                                             
        self.label_value1a = QLabel("value1a Data File:")
        self.layout_scroll_value1a.addWidget(self.label_value1a)

        self.button_value1a = QPushButton("Open value1a Data File")
        self.button_value1a.clicked.connect(self.open_value1a_data_file)
        self.layout_scroll_value1a.addWidget(self.button_value1a)

        self.label_usl_value1a = QLabel("USL (value1a):")
        self.layout_scroll_value1a.addWidget(self.label_usl_value1a)

        self.input_usl_value1a = QLineEdit()
        self.layout_scroll_value1a.addWidget(self.input_usl_value1a)

        self.label_lsl_value1a = QLabel("LSL (value1a):")
        self.layout_scroll_value1a.addWidget(self.label_lsl_value1a)

        self.input_lsl_value1a = QLineEdit()
        self.layout_scroll_value1a.addWidget(self.input_lsl_value1a)

                                                                             
        self.label_Value2 = QLabel("Value2 Data File:")
        self.layout_scroll_Value2.addWidget(self.label_Value2)

        self.button_Value2 = QPushButton("Open Value2 Data File")
        self.button_Value2.clicked.connect(self.open_Value2_data_file)
        self.layout_scroll_Value2.addWidget(self.button_Value2)

        self.label_usl_Value2 = QLabel("USL (Value2):")
        self.layout_scroll_Value2.addWidget(self.label_usl_Value2)

        self.input_usl_Value2 = QLineEdit()
        self.layout_scroll_Value2.addWidget(self.input_usl_Value2)

        self.label_lsl_Value2 = QLabel("LSL (Value2):")
        self.layout_scroll_Value2.addWidget(self.label_lsl_Value2)

        self.input_lsl_Value2 = QLineEdit()
        self.layout_scroll_Value2.addWidget(self.input_lsl_Value2)

        self.analyze_button = QPushButton("Analyze")
        self.analyze_button.clicked.connect(self.analyze_data)
        self.layout_scroll_Value2.addWidget(self.analyze_button)

        self.target_value1a = None
        self.target_Value2 = None

    def open_value1a_data_file(self):
        file_dialog = QFileDialog()
        file_path, _ = file_dialog.getOpenFileName(self, "Open value1a Data File", "", "CSV Files (*.csv)")

        if file_path:
            self.label_value1a.setText(file_path)
            self.target_value1a = value1aManufacturingTarget(file_path)

    def open_Value2_data_file(self):
        file_dialog = QFileDialog()
        file_path, _ = file_dialog.getOpenFileName(self, "Open Value2 Data File", "", "CSV Files (*.csv)")

        if file_path:
            self.label_Value2.setText(file_path)
            self.target_Value2 = Value2ManufacturingTarget(file_path)

    def analyze_data(self):
        usl_value1a = float(self.input_usl_value1a.text())
        lsl_value1a = float(self.input_lsl_value1a.text())

        usl_Value2 = float(self.input_usl_Value2.text())
        lsl_Value2 = float(self.input_lsl_Value2.text())

        if self.target_value1a:
            self.target_value1a.run_all(usl_value1a, lsl_value1a)
        else:
            print("No value1a data file selected")

        if self.target_Value2:
            self.target_Value2.run_all(usl_Value2, lsl_Value2)
        else:
            print("No Value2 data file selected")


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())                                                        #Initializes application, creates main window, displays it, and starts the application event loop
